package com.lunatech.dto

import java.util.UUID

import com.lunatech.game.Constants

/**
 * Game Status DTO (See Swagger Spec definition)
 * @param status game status (either 'player_turn' or 'won', see `Constants.GameStatus`)
 * @param owner game status' owner (one of the two players).
 */
case class GameInfo(status: String, owner: String) {
  require(Option(status).exists(_.trim.nonEmpty), "The 'status' field must not be empty nor null.")
  require(Option(owner).exists(_.trim.nonEmpty), "The 'owner' field must not be empty nor null.")
  require(status == Constants.GameStatus.playerTurn || status == Constants.GameStatus.won, "The 'status' field must be 'player_turn' or 'won'")
}

/**
 * Board DTO (See Swagger Spec definition)
 * @param userId Board's owner
 * @param board Board encoded into an array of strings (each element represents a row).
 */
case class Board(userId: String, board: Array[String]) {
  require(Option(userId).exists(_.trim.nonEmpty), "The 'userId' field must not be empty nor null.")
  require(Option(board).exists(_.length == Constants.boardSize), "Board must have the proper length.")
  require(board.forall(_.length == Constants.boardSize), "Each row must have the proper length.")
  // TODO check elements of board, if matches against possible values.
}

/**
 * Trait for all HTTP Messages, see `BattleshipHttpRequest`.
 */
sealed trait HttpMessage

/**
 * Request a New Game.
 * @param userId user id requesting a new game.
 * @param fullName user full name.
 * @param protocol this is the opponent's protocol (depends on User o Protocol API)
 * @param rules which rules the requesting player wants to play.
 */
case class RequestNewGame(userId: String, fullName: Option[String], protocol: String, rules: String) extends HttpMessage {
  require(Option(userId).exists(_.trim.nonEmpty), "The 'userId' field must not be empty nor null.")
  require(Option(protocol).exists(_.trim.nonEmpty), "The 'protocol' field must not be empty nor null.")
  require(Option(rules).exists(_.trim.nonEmpty), "The 'rules' field must not be empty nor null.")
  require(protocol.matches("\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}:\\d+"), "The 'protocol' field must be a valid IP")
  require(Constants.Rules.allRules.contains(rules), "The 'rules' must be a valid value")
}

/**
 * Responds (and accepts) to a new game.
 * @param userId opponent's user id.
 * @param fullName opponent's user full name.
 * @param gameId game Id.
 * @param starting player's id who starts the game (randomly one or the other).
 * @param rules which rules the requesting player wants to play (any disparity is an error).
 */
case class ResponseNewGame(userId: String, fullName: String, gameId: UUID, starting: String, rules: String) extends HttpMessage {
  require(Option(userId).exists(_.trim.nonEmpty), "The 'userId' field must not be empty nor null.")
  require(Option(fullName).exists(_.trim.nonEmpty), "The 'fullName' field must not be empty nor null.")
  require(Option(gameId).isDefined, "The 'gameId' field must not be empty nor null.")
  require(Option(starting).exists(_.trim.nonEmpty), "The 'starting' field must not be empty nor null.")
  require(Option(rules).exists(_.trim.nonEmpty), "The 'rules' field must not be empty nor null.")
  require(Constants.Rules.allRules.contains(rules), "The 'rules' must be a valid value")
}

/**
 * Request to shot.
 * - For User API: this means we want to shot the opponent.
 * - For Protocol API: this means we are receiving a shot.
 * @param shots an array of positions encoded as hex values (eg. Ax1, 2xF, 4xE)
 */
case class RequestShot(shots: Array[String]) extends HttpMessage {
  require(Option(shots).exists(_.nonEmpty), "The 'shots' field must not be empty nor null.")
  require(shots.forall(Constants.Shots.isShot), s"Shots must be in the proper format: '${shots}'")
}

/**
 * Response to a shot, for both API is the same response, User API must return the same
 * as the one generated by the Protocol API.
 * @param game new game status.
 * @param shots a map of positions to shot status (miss, hit or kill).
 */
case class ResponseShot(game: GameInfo, shots: Map[String, String]) extends HttpMessage {
  require(Option(game).isDefined, "The 'game' field must not be empty nor null.")
  require(Option(shots).exists(_.nonEmpty), "The 'shots' field must not be empty nor null.")
  require(shots.forall(posStatus => Constants.Shots.isShot(posStatus._1) && Constants.Shots.allShots.contains(posStatus._2)), "The 'shots' field must in proper format.")
}

/**
 * Request to put a game into auto pilot
 */
case object RequestAutopilot extends HttpMessage

/**
 * Response to put a game into auto pilot
 */
case object ResponseAutopilot extends HttpMessage // When OK

/**
 * Request to get a game's status.
 */
case object RequestGameStatus extends HttpMessage

/**
 * Response of a game status.
 * @param game game status.
 * @param self this instance's player board.
 * @param opponent opponent's board (mostly hidden cells).
 */
case class ResponseGameStatus(game: GameInfo, self: Board, opponent: Board) extends HttpMessage {
  require(Option(game).isDefined, "The 'game' field must not be empty nor null.")
  require(Option(self).isDefined, "The 'self' field must not be empty nor null.")
  require(Option(opponent).isDefined, "The 'opponent' field must not be empty nor null.")
}

/**
 * HTTP request for both User and Procotol API.
 *
 * @param gameId optional game ID (eg. New game requests doesn't have a Game ID)
 * @param msg HTTPMessage in the request (aka. Body)
 * @param isUserRequest if it's either a User or Protocol API request (since they share body types).
 */
case class BattleshipHttpRequest(gameId: Option[UUID], msg: HttpMessage, isUserRequest: Boolean)

object BattleshipHttpRequest {

  /**
   * Factory for new game requests.
   */
  def apply(msg: HttpMessage, isUserRequest: Boolean): BattleshipHttpRequest =
    BattleshipHttpRequest(None, msg, isUserRequest)
}

object Utils {

  /**
   * Creates an empty board according to game rules.
   * @param userId board's owner
   * @return Board instance.
   */
  def emptyBoard(userId: String): Board =
    Board(
      userId,
      (1 to Constants.boardSize).map { _ =>
        (1 to Constants.boardSize).map(_ => Constants.emptyCell).mkString("")
      }.toArray)
}
